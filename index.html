<!DOCTYPE html>
<html>
<head>
  <title>Teachable Machine with MQTT</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest"></script>
  <script src="https://cdn.jsdelivr.net/npm/@teachablemachine/image@latest"></script>
  <script src="https://unpkg.com/paho-mqtt/mqttws31.min.js"></script>
</head>
<body>
  <h3>Teachable Machine Image Model + MQTT (Mobile)</h3>
  <button onclick="init('environment')">Start (Back Camera)</button>
  <button onclick="init('user')">Start (Front Camera)</button>
  <button onclick="stop()">Stop</button>
  <div id="webcam-container"></div>
  <div id="label-container"></div>

  <script type="text/javascript">
    const URL = "https://teachablemachine.withgoogle.com/models/klxDOYTDp/";
    let model, webcam, labelContainer, maxPredictions;
    let client, isConnected = false;
    let lastClassName = "";
    let isWaiting = false;

    async function init(facingMode) {
      model = await tmImage.load(URL + "model.json", URL + "metadata.json");
      maxPredictions = model.getTotalClasses();

      webcam = new tmImage.Webcam(224, 224, false);
      await webcam.setup({ facingMode });
      await webcam.play();
      document.getElementById("webcam-container").appendChild(webcam.canvas);
      window.requestAnimationFrame(loop);

      labelContainer = document.getElementById("label-container");
      labelContainer.innerHTML = Array(maxPredictions).fill().map(() => "<div>").join("");

      mqttConnect();
    }

    async function loop() {
      webcam.update();
      await predict();
      window.requestAnimationFrame(loop);
    }

    async function predict() {
      if (isWaiting) return;

      const prediction = await model.predict(webcam.canvas);
      const topClass = prediction.reduce((max, p) => p.probability > max.probability ? p : max);

      prediction.forEach((p, i) => {
        labelContainer.childNodes[i].innerHTML = `${p.className}: ${p.probability.toFixed(2)}`;
      });

      if (topClass.probability >= 0.9) {
        isWaiting = true;

        // แสดงผลลัพธ์ค้างไว้ 5 วิ
        console.log("พบความมั่นใจสูง: รอ 5 วิ");
        await delay(5000);

        // ส่งข้อมูลไปยัง MQTT ใช้เวลา 3 วิ
        const msg = JSON.stringify({
          type: topClass.className,
          confidence: topClass.probability.toFixed(2)
        });

        console.log("ส่ง MQTT:", msg);
        sendMQTT(msg);

        await delay(3000);

        // จบการรอค้าง
        isWaiting = false;
      }
    }

    function delay(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }

    function stop() {
      if (webcam) {
        webcam.stop();
        document.getElementById("webcam-container").innerHTML = "";
        document.getElementById("label-container").innerHTML = "";
      }
    }

    function mqttConnect() {
      const clientId = "web_" + Math.floor(Math.random() * 10000);
      client = new Paho.MQTT.Client("broker.hivemq.com", 8884, clientId);
      client.connect({
        useSSL: true,
        onSuccess: () => {
          console.log("เชื่อมต่อ MQTT สำเร็จ");
          isConnected = true;
        },
        onFailure: (e) => {
          console.error("การเชื่อมต่อ MQTT ล้มเหลว:", e.errorMessage);
          isConnected = false;
        }
      });
    }

    function sendMQTT(message) {
      if (client && isConnected) {
        const topic = "ktmn";
        const msg = new Paho.MQTT.Message(message);
        msg.destinationName = topic;
        client.send(msg);
        console.log("ส่งสำเร็จ:", message);
      } else {
        console.warn("ยังไม่เชื่อมต่อ MQTT:", message);
      }
    }
  </script>
</body>
</html>
