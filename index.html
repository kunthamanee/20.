<!DOCTYPE html>  <html>  
<head>  
  <title>Teachable Machine Image Model (Mobile)</title>  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">  
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest/dist/tf.min.js"></script>  
  <script src="https://cdn.jsdelivr.net/npm/@teachablemachine/image@latest/dist/teachablemachine-image.min.js"></script>  
  <script src="https://unpkg.com/paho-mqtt/mqttws31.min.js"></script>    <style>  
    body {  
      font-family: Arial, sans-serif;  
      text-align: center;  
      margin: 0;  
      padding: 0;  
    }  
    #webcam-container {  
      max-width: 100%;  
      margin: 10px auto;  
    }  
    video {  
      max-width: 100%;  
      height: auto;  
    }  
    #label-container {  
      margin: 10px;  
      font-size: 1.2em;  
    }  
    button {  
      padding: 10px 20px;  
      font-size: 1em;  
      margin: 5px;  
    }  
  </style>  </head>  
<body>  
  <div>Teachable Machine Image Model (Mobile)</div>  
  <button type="button" onclick="init('environment')">Start (Back Camera)</button>  
  <button type="button" onclick="init('user')">Start (Front Camera)</button>  
  <button type="button" onclick="stop()">Stop</button>  
  <div id="webcam-container"></div>  
  <div id="label-container"></div>    <script type="text/javascript">  
    const URL = "https://teachablemachine.withgoogle.com/models/klxDOYTDp/";  
  
    let model, webcam, labelContainer, maxPredictions;  
    let client;  
  
    async function init(facingMode) {  
      const modelURL = URL + "model.json";  
      const metadataURL = URL + "metadata.json";  
  
      model = await tmImage.load(modelURL, metadataURL);  
      maxPredictions = model.getTotalClasses();  
  
      webcam = new tmImage.Webcam(224, 224, false);  
      try {  
        await webcam.setup({ facingMode: facingMode });  
        await webcam.play();  
        if (!webcam.canvas) {  
          throw new Error("Webcam canvas is not initialized");  
        }  
        console.log("Webcam initialized");  
        window.requestAnimationFrame(loop);  
      } catch (e) {  
        console.error("Webcam setup failed:", e);  
        document.getElementById("label-container").innerText = "Error: " + e.message;  
        return;  
      }  
  
      document.getElementById("webcam-container").appendChild(webcam.canvas);  
      labelContainer = document.getElementById("label-container");  
      labelContainer.innerHTML = "";  
      for (let i = 0; i < maxPredictions; i++) {  
        labelContainer.appendChild(document.createElement("div"));  
      }  
  
      mqttConnect();  
    }  
  
    async function loop() {  
      webcam.update();  
      await predict();  
      window.requestAnimationFrame(loop);  
    }  
  
    async function predict() {  
      const prediction = await model.predict(webcam.canvas);  
      let topClass = prediction[0];  
  
      for (let i = 0; i < maxPredictions; i++) {  
        const p = prediction[i];  
        const classPrediction = p.className + ": " + p.probability.toFixed(2);  
        labelContainer.childNodes[i].innerHTML = classPrediction;  
  
        if (p.probability > topClass.probability) {  
          topClass = p;  
        }  
      }  
  
      if (topClass.probability > 0.8) {  
        sendMQTT(topClass.className);  
      }  
    }  
  
    function stop() {  
      if (webcam) {  
        webcam.stop();  
        document.getElementById("webcam-container").innerHTML = '';  
        document.getElementById("label-container").innerHTML = '';  
      }  
    }  
  
    function mqttConnect() {  
      client = new Paho.MQTT.Client("broker.hivemq.com", 8884, "web_" + Math.floor(Math.random() * 10000));
  client.connect({
  useSSL: true, // ต้องเพิ่มบรรทัดนี้เพื่อใช้ wss://
  onSuccess: () => {
    console.log("Connected to MQTT (Secure WebSocket)");
  },
  onFailure: (e) => {
    console.error("MQTT connection failed:", e.errorMessage);
  }
});
    }  
  
    function sendMQTT(message) {  
      if (client && client.isConnected()) {  
        const topic = "ktmn";  
        const msg = new Paho.MQTT.Message(message);  
        msg.destinationName = topic;  
        client.send(msg);  
        console.log("MQTT message sent:", message);  
      }  
    }  
  </script>  </body>  
</html>
